<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Generic Application Programming Interface (API) for Sliding Window FEC Codes</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Definitions and Abbreviations"/>
<link href="#rfc.section.3" rel="Chapter" title="3 AL-FEC Codes and Mechanisms Considered by the Generic API"/>
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Mechanisms Considered or Ignored by the API"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Generic API for Sliding Window FEC Codes"/>
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 General Definitions Common to the Encoder and Decoder"/>
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Coding Window Functions at an Encoder and Decoder"/>
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Coding Coefficients Functions at an Encoder and Decoder"/>
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Encoder"/>
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Decoder"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.6" rel="Chapter" title="6 IANA Considerations"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgments"/>
<link href="#rfc.references" rel="Chapter" title="8 References"/>
<link href="#rfc.references.1" rel="Chapter" title="8.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="8.2 Informative References"/>


  <meta name="generator" content="xml2rfc version 2.4.8 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Roca (Ed.), V., Detchart, J., Adjih, C., and M. Pedersen" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-roca-nwcrg-generic-fec-api-04" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-11-2" />
  <meta name="dct.abstract" content="This document introduces a generic Application Programming Interface (API) for sliding window FEC codes.  This API is meant to be compatible with any sliding window FEC code.  It defines the core procedures and functions meant to control the codec (i.e., implementation of the FEC code).  However, it leaves out all upper layer aspects that are the responsibility of the application or protocol making use of the codec.  As a consequence, this is not an API for a FEC Scheme since certain mechanisms that must be defined by any FEC Scheme (e.g., signalling and FEC Payload IDs) are the responsibility of the caller instead of being addressed by the codec.  A first goal of this document is to pave the way for a future open-source implementation of such codes, another goal is to simplify the development of content delivery protocols that rely on sliding window FEC codes for robust transmissions.  " />
  <meta name="description" content="This document introduces a generic Application Programming Interface (API) for sliding window FEC codes.  This API is meant to be compatible with any sliding window FEC code.  It defines the core procedures and functions meant to control the codec (i.e., implementation of the FEC code).  However, it leaves out all upper layer aspects that are the responsibility of the application or protocol making use of the codec.  As a consequence, this is not an API for a FEC Scheme since certain mechanisms that must be defined by any FEC Scheme (e.g., signalling and FEC Payload IDs) are the responsibility of the caller instead of being addressed by the codec.  A first goal of this document is to pave the way for a future open-source implementation of such codes, another goal is to simplify the development of content delivery protocols that rely on sliding window FEC codes for robust transmissions.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">NWCRG</td>
  <td class="right">V. Roca (Ed.)</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">INRIA</td>
</tr>
<tr>
  <td class="left">Intended status: Informational</td>
  <td class="right">J. Detchart</td>
</tr>
<tr>
  <td class="left">Expires: May 6, 2019</td>
  <td class="right">ISAE - Supaero</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">C. Adjih</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">INRIA</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">M. Pedersen</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Steinwurf ApS</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">November 2, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Generic Application Programming Interface (API) for Sliding Window FEC Codes<br />
  <span class="filename">draft-roca-nwcrg-generic-fec-api-04</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document introduces a generic Application Programming Interface (API) for sliding window FEC codes.  This API is meant to be compatible with any sliding window FEC code.  It defines the core procedures and functions meant to control the codec (i.e., implementation of the FEC code).  However, it leaves out all upper layer aspects that are the responsibility of the application or protocol making use of the codec.  As a consequence, this is not an API for a FEC Scheme since certain mechanisms that must be defined by any FEC Scheme (e.g., signalling and FEC Payload IDs) are the responsibility of the caller instead of being addressed by the codec.  A first goal of this document is to pave the way for a future open-source implementation of such codes, another goal is to simplify the development of content delivery protocols that rely on sliding window FEC codes for robust transmissions.  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 6, 2019.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Definitions and Abbreviations</a></li>
<li>3.   <a href="#rfc.section.3">AL-FEC Codes and Mechanisms Considered by the Generic API</a></li>
<li>3.1.   <a href="#rfc.section.3.1">Mechanisms Considered or Ignored by the API</a></li>
<li>4.   <a href="#rfc.section.4">Generic API for Sliding Window FEC Codes</a></li>
<li>4.1.   <a href="#rfc.section.4.1">General Definitions Common to the Encoder and Decoder</a></li>
<li>4.2.   <a href="#rfc.section.4.2">Coding Window Functions at an Encoder and Decoder</a></li>
<li>4.3.   <a href="#rfc.section.4.3">Coding Coefficients Functions at an Encoder and Decoder</a></li>
<li>4.4.   <a href="#rfc.section.4.4">Encoder</a></li>
<li>4.5.   <a href="#rfc.section.4.5">Decoder</a></li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<li>6.   <a href="#rfc.section.6">IANA Considerations</a></li>
<li>7.   <a href="#rfc.section.7">Acknowledgments</a></li>
<li>8.   <a href="#rfc.references">References</a></li>
<li>8.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>8.2.   <a href="#rfc.references.2">Informative References</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">Forward Erasure Correction (FEC) codes are a key element of communication systems, used to efficiently recover from packet losses during content delivery sessions.  Among the FEC codes working at the network and higher layers, one can broadly distinguish block codes and sliding window codes.  Block FEC codes require the data flow coming from the application to be segmented into blocks of a predefined maximum size, before generating a certain number of repair packets.  With the second type of FEC codes, an encoding window continuously slides over the set of source data and repair packets are generated at any time by computing for instance a linear combination of data present in the encoding window.  This fundamental difference seriously impacts the way they can be used by a content delivery protocol or application.  </p>
<p id="rfc.section.1.p.2">This document introduces a generic Application Programming Interface (API) for sliding window FEC codes.  This API is meant to be usable by any sliding window FEC code and FEC Scheme independently of the protocol that may rely on it.  This API defines the core procedures and functions meant to control the codec (i.e., implementation of the FEC code), but leaves out all upper layer aspects that are the responsibility of the application making use of the codec.  </p>
<p id="rfc.section.1.p.3">This API is meant to be usable by any sliding window FEC code.  independently of the FEC Scheme or network coding protocol that may rely on it This API defines the core procedures and functions meant to control the codec (i.e., implementation of the FEC code), but leaves out all upper layer aspects that are the responsibility of the application making use of the codec.  For instance, those restricted to end-to-end use-cases as well as those compatible with in-network re-encoding use-cases.  Additionally, this API is not impacted by the intra-flow versus inter-flow nature of the use-case, nor is it impacted by the single-path versus multi-paths nature of the use-case, since those are usage considerations under the responsibility of the caller.  </p>
<p id="rfc.section.1.p.4">A goal of this document is to pave the way for a future open-source implementation of such codes.  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#definitionsAndAbbreviations" id="definitionsAndAbbreviations">Definitions and Abbreviations</a></h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.  </p>
<p id="rfc.section.2.p.2">This document uses the following definitions and abbreviations: </p>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">XXX</dd>
</dl>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#mechanismsConsidered" id="mechanismsConsidered">AL-FEC Codes and Mechanisms Considered by the Generic API</a></h1>
<p id="rfc.section.3.p.1">This generic FEC API is meant to be used with: </p>

<ul>
  <li>sliding window codes, that manage an encoding window (of fixed or variable size) that slides over the set of source symbols at the sender.  On the opposite, block codes (e.g., Reed-Solomon, LDPC, Raptor(Q)) are out of scope; </li>
  <li>codes that are restricted to use-cases that involve a single encoding point and a single decoding point (i.e., FEC operations are carried out either within the end-hosts or middle-boxes), as well as codes that can be used with use-cases that involve in-network re-coding operations;</li>
  <li>use-cases that are limited to an intra-flow coding (simple case), as well as use-cases that involve inter-flow coding.  This second case is more complex to address (e.g., with questions such as how to identify a packet of a flow?) however this is the responsibility of the application or protocol using this codec and not the codec itself.  This aspect is therefore transparent to the API;</li>
  <li>use-cases that are limited to single-path communications and use-cases that consider multi-path communications.  Here also this is a usage consideration that is transparent to the API;</li>
  <li>use-cases that involve a dynamic adaptation of the codec parameters (e.g., its code rate because the communication path losses is known thanks to feedbacks and an appropriate strategy can be defined);</li>
  <li>fixed code rate or not FEC codes, including rateless codes where the number of repair symbols that can be generated is huge (in theory unlimited);</li>
  <li>ideal (MDS) or non-ideal (non-MDS) codes. However most of the time, sliding window codes are non-ideal codes, meaning that slightly more than l repair symbols may be required to recover all the l lost source symbols;</li>
</ul>

<p> </p>
<p id="rfc.section.3.p.2">A key question is to determine what mechanisms are included in the codec and what mechanisms are left to the responsibility of the caller (i.e., an application or a protocol making use of this codec) (<a href="#fig_codec_vs_fec_scheme_anc_protocol">Figure 1</a>).  More precisely, an FEC Scheme (such as the RLC FEC Scheme <a href="#RLC">[RLC]</a> in case of FECFRAME <a href="#fecframe-ext">[fecframe-ext]</a>) defines all the internal code details in order to enable interoperable implementations, but also signaling considerations that are essential to use them in a specific context.  </p>
<div id="rfc.figure.1"/>
<div id="fig_codec_vs_fec_scheme_anc_protocol"/>
<pre>
+----------------------------------------------------------+
|         Application / Protocol Mechanisms                |
|                    (out of scope)                        |
|                                                          |
|            + - - - - - - - - - - - - - - - - - - - - - + |
|                             FEC Scheme                   |
|         +--|-------------------------------------------|-+
|         |                                               
|         |  |  &lt;----- FEC Codec API (this doc.) -----&gt;  |
|         |    +---------------------------------------+  
|         |  | |         Low Level FEC Codec           | |
|         |    +---------------------------------------+  
+---------+  + - - - - - - - - - - - - - - - - - - - - - +
</pre>
<p class="figure">Figure 1: Position of the FEC Codec API with respect to the low level FEC Codec, the FEC Scheme, the protocol and other caller services.</p>
<h1 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a> <a href="#mechanismsConsideredOrIgnored" id="mechanismsConsideredOrIgnored">Mechanisms Considered or Ignored by the API</a></h1>
<p id="rfc.section.3.1.p.1">Applying FEC coding, through an FEC Scheme, in a given protocol to improve transmission robustness involves many mechanisms.  However, these mechanisms are not all the responsibility of the codec and can be implemented within the application or within the protocol that uses this FEC codec.  For instance, the following mechanisms are considered **out of scope of the API**, being implemented by the caller, without any impact on the codec: </p>

<ul>
  <li>memory management; </li>
  <li>packet transmission and reception; </li>
  <li>signaling header creation / parsing; </li>
  <li>ADU to source symbol mapping; </li>
  <li>code rate adjustment, for instance thanks to the knowledge of losses at a receiver via feedbacks; </li>
  <li>selective ACK creation and parsing; </li>
  <li>congestion control. </li>
</ul>

<p> </p>
<p id="rfc.section.3.1.p.2">The following mechanisms are **within scope of the API**: </p>

<ul>
  <li>session management (sender and receiver); </li>
  <li>encoding window management (sender and receiver); </li>
  <li>set/get/generate coding coefficients (sender and receiver); </li>
  <li>build coded symbol (sender only); </li>
  <li>decode with newly received source or repair symbol (receiver only); </li>
</ul>

<p> </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#genericAPI" id="genericAPI">Generic API for Sliding Window FEC Codes</a></h1>
<p id="rfc.section.4.p.1">The following sections describe the generic API, following a C-language formalism.  This API tries to adhere to C99 version of C, although it may not strictly be guaranteed.  Everything is prefixed by "ga" (Generic API).  </p>
<h1 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a> General Definitions Common to the Encoder and Decoder</h1>
<p id="rfc.section.4.1.p.1">This section gathers general definitions that are used by both an encoder and decoder.  </p>
<p id="rfc.section.4.1.p.2">About FEC Codepoints: </p>

<dl>
  <dt></dt>
  <dd style="margin-left: 8">An application first needs to negotiate with its remote side the right FEC Scheme to use.  This negotiation usually relies on the FEC Encoding ID associated to this FEC Scheme for this application.  The FEC Encoding ID space, associated to an IANA registry, is protocol specific and the same value are usually associated to different FEC Schemes depending on the protocol.  The FEC Encoding ID, from the Generic FEC API point of view, cannot be used to uniquely identify the codec.  </dd>
  <dt></dt>
  <dd style="margin-left: 8">The use of a codepoint to identify locally the right FEC codec requires that the application knows a mapping between the FEC Encoding ID it uses and the local FEC Codepoints corresponding to available codecs.  This can be done at development time, after including the Generic FEC API header file, which gives access to the swif_codepoint_t enumeration.  </dd>
</dl>
<pre>
&lt;CODE BEGINS&gt;
/**
 * Return value of any function.
 *
 * SWIF_STATUS_OK = 0   Success
 * SWIF_STATUS_FAILURE  Failure. The function called did not succeed to
 *                      perform its task, however this is not an error
 *                      (e.g., it happens when decoding fails).
 * SWIF_STATUS_ERROR    Generic error type. The detailed error type is
 *                      stored in the errno variable of swif_encoder_t and
 *                      swif_decoder_t structures.
 */
typedef enum {
        SWIF_STATUS_OK = 0,
        SWIF_STATUS_FAILURE,
        SWIF_STATUS_ERROR
} swif_status_t;


/**
 * Potential errors.
 */
typedef enum {
        SWIF_ERRNO_NIL = 0,
        SWIF_ERRNO_CODEPOINT_NOT_SUPPORTED,
        /* and many more... */
} swif_errno_t;


/**
 * FEC Codepoints.
 * These identifiers are opaque identifiers that fully identify an FEC
 * code locally, including certain parameters like its Galois Field, or
 * the coding coefficient generator (if several exist).
 * These codepoints are codec specific and only have a local meaning.
 * They should not be transmitted as different implementations may use
 * them inconsistently.
 * Note that the same FEC code may be used by several FEC Encoding IDs
 * and therefore share the same codepoint. On the opposite multiple
 * implementations of a given FEC code may exist locally, for instance
 * with different optimizations, and then several codepoints, one per
 * codec, will exist for the same FEC code. The following names are
 * therefore only provided as examples.
 */
typedef enum {
        swif_NULL_CODEPOINT = 0,        /* codepoint 0 is reserved */

        /* codepoint for RLC sliding window code, GF(2^8) and variable
         * density (as in FECFRAME FEC Enc. ID XXX). */
        swif_RLC_GF_256_VAR_DENSITY_CODEC,

        /* codepoint for RLC sliding window code, GF(2) and variable
         * density (as in FECFRAME FEC Enc. ID YYY). */
        swif_RLC_GF_2_VAR_DENSITY_CODEC,

        /* list here other identifiers for any codec of interest... */
} swif_codepoint_t;


/**
 * Encoding Symbol Identifier (ESI) generic type. 
 * With Sliding Window FEC codes, an ESI is in fact a source symbol
 * identifier, unlike block FEC codes.
 */
typedef uint32_t	esi_t
&lt;CODE ENDS&gt;
</pre>
<p class="figure">General definitions.</p>
<h1 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2.</a> Coding Window Functions at an Encoder and Decoder</h1>
<p id="rfc.section.4.2.p.1">This section gathers functions used to manage the coding window, both at an encoder and at a decoder.  At an encoder a sliding (of fixed or elastic size) encoding window is managed. Whenever a repair symbol needs to be created, a linear combination (that is code specific) of source symbols currently in the encoding window is performed. This encoding window is managed with the functions below plus, potentially, internal mechanisms that are code specific.  </p>
<p id="rfc.section.4.2.p.2">At a decoder, before submitting a new repair symbol to the codec, the application must specify the associated encoding window used at the source. This is done by the reset/add a single or set of symbols/remove a symbol functions.  Once this coding window is ready, as well as the coding coefficient list if applicable, the application calls the decode_with_new_repair_symbol() function. A coding window may be reused for several repair symbols as long as they are all built from the same set of source symbols. In that case resetting the coding window and setting it from scratch would be a waste of time. The coding window must be viewed as a temporary list used solely by the decode_with_new_repair_symbol() function and kept independent from the linear system managed by the codec.  </p>
<pre>
&lt;CODE BEGINS&gt;
/**
 * This function resets the current coding window. We assume here that
 * this window is maintained by the FEC codec instance.
 * Encoder:     reset the encoding window for the encoding of future
 *              repair symbols.
 * Decoder:     reset the coding window under preparation associated to
 *              a repair symbol just received.
 *
 * @return
 */
swif_status_t   swif_encoder_reset_coding_window (swif_encoder_t*  enc);

swif_status_t   swif_decoder_reset_coding_window (swif_encoder_t*  dec);


/**
 * Add a sequential set of source symbols (there MUST NOT be any gap) to
 * the coding window. This function may be called several times if there
 * are gaps in the encoding window. Calling this function does not reset
 * the current coding window, but appends these source symbols to it.
 *
 * Encoder:     add this sequential set of source symbols to the encoding
 *              window. The pointers in the table MUST point to the
 *              corresponding source symbol buffers.
 * Decoder:     add this source symbol set to the coding window under
 *              preparation.
 *
 * @param new_src_symbol_buf_tab (Encoder only) table of pointers to
 *              buffers containing each source symbol. The application
 *              MUST NOT free nor modify these buffers as long as the
 *              corresponding source symbol is in the encoding window.
 * @param first_src_symbol_esi  ESI of the first source symbol in table
 * @param nb_symbols_in_tab     total number of symbols in this table.
 * @return
 */
swif_status_t   swif_encoder_add_source_symbol_tab_to_coding_window  (
                                swif_encoder_t* enc,
                                void*           new_src_symbol_buf_tab[],
                                esi_t           first_src_symbol_esi,
                                uint32_t        nb_symbols_in_tab);

swif_status_t   swif_decoder_add_source_symbol_tab_to_coding_window  (
                                swif_decoder_t* dec,
                                esi_t           first_src_symbol_esi,
                                uint32_t        nb_symbols_in_tab);


/**
 * Add this source symbol to the coding window.
 * Encoder:     add a source symbol to the coding window.
 * Decoder:     add a source symbol to the coding window under preparation.
 *
 * @param new_src_symbol_buf    (encoder only) pointer to a buffer
 *              containing the source symbol. The application MUST NOT
 *              free nor modify this buffer as long as the source symbol
 *              is in the coding window.
 * @param new_src_symbol_esi    ESI of the source symbol to add.
 * @return
 */
swif_status_t   swif_encoder_add_source_symbol_to_coding_window (
                                swif_encoder_t* enc,
                                void*           new_src_symbol_buf,
                                esi_t           new_src_symbol_esi);

swif_status_t   swif_decoder_add_source_symbol_to_coding_window (
                                swif_decoder_t* dec,
                                esi_t           new_src_symbol_esi);


/**
 * Remove this source symbol from the coding window.
 *
 * Encoder:     remove a source symbol from the encoding window, e.g.
 *              because the application knows that a source symbol has
 *              been acknowledged by the peer (if applicable). Note that
 *              the left side of the sliding window is automatically
 *              managed by the codec and no action is needed from the
 *              application. If needed a callback is available to inform
 *              the application that a source symbol has been removed).
 * Decoder:     remove a source symbol from the coding window under
 *              preparation.
 *
 * @param old_src_symbol_esi    ESI of the source symbol to remove from
 *              the coding window.
 * @return
 */
swif_status_t   swif_encoder_remove_source_symbol_from_coding_window (
                                swif_encoder_t* enc,
                                esi_t           old_src_symbol_esi);

swif_status_t   swif_decoder_remove_source_symbol_from_coding_window (
                                swif_decoder_t* dec,
                                esi_t           old_src_symbol_esi);
&lt;CODE ENDS&gt;
</pre>
<p class="figure">Coding Window Functions at an Encoder and Decoder.</p>
<h1 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3.</a> Coding Coefficients Functions at an Encoder and Decoder</h1>
<p id="rfc.section.4.3.p.1">This section gathers functions used to manage the coding coefficients, both at an encoder and at a decoder.  Since different FEC codecs will have different requirements, it is important to keep these functions separate from the build_repair_symbol() and decode_with_new_repair_symbol() functions.  Several situations exist: </p>

<ul>
  <li>the application provides the list of coding coefficients to use for the next build_repair_symbol(); </li>
  <li>the application provides a key (typically a PRNG seed) that the codec uses to produce the coding coefficients to use for the next build_repair_symbol();</li>
  <li>the choice of the coding coefficients is totally performed by the codec, in an autonomous manner (e.g., the codec includes an algorithm that produces an appropriate seed based on various criteria, or the codec selects a set of coding coefficients based on various criteria).  In that case the application needs to retrieve the list of coding coefficients or the key selected by the codec;</li>
</ul>

<p> </p>
<pre>
&lt;CODE BEGINS&gt;
/** 
 * The following functions enable an encoder (resp. decoder) to
 * initialize the set of coefficients to be used for encoding
 * or associated to a received repair symbol.
 *
 * Encoder: calling one of them MUST be done before calling
 *              build_repair_symbol().
 * Decoder: calling one of them MUST be done before calling
 *              decode_with_new_repair_symbol().
 */

/**
 * Encoder: this function specifies the coding coefficients chosen by
 *          the application if this is the way the codec works.
 * Decoder: communicate with this function the coding coefficients
 *          associated to a repair symbol and carried in the packet
 *          header.
 *
 * @param coding_coefs_tab
 *              (IN) table of coding coefficients associated to each of
 *              the source symbols currently in the encoding window.
 *              The size (number of bits) of each coefficient depends on
 *              the FEC Scheme. The allocation and release of this table
 *              is under the responsibility of the application.
 * @param nb_coefs_in_tab      
 *              (IN) number of entries (i.e., coefficients) in the table.
 * @return
 */
swif_status_t   swif_encoder_set_coding_coefs_tab (
                                swif_encoder_t* enc,
                                void*           coding_coefs_tab,
                                uint32_t        nb_coefs_in_tab);

swif_status_t   swif_decoder_set_coding_coefs_tab (
                                swif_decoder_t* dec,
                                void*           coding_coefs_tab,
                                uint32_t        nb_coefs_in_tab);


/**
 * The coding coefficients may be generated in a deterministic manner,
 * for instance by a PRNG known by the codec and a seed (perhaps with
 * other parameters) provided by the application.
 * The codec may also choose in an autonomous manner these coefficients.
 * This function is used to trigger this process.
 * When the choice is made in an autonomous manner, the actual coding
 * coefficient or key used by the codec can be retrieved with
 * swif_encoder_get_coding_coefs_tab().
 *
 * @param key   (IN) Value that can be used as a seed in case of a PRNG
 *              for instance, or by a specific coding coefficients
 *              function. Set to 0 if not required by a codec.
 * @param add_param
 *              (IN) an opaque 32-bit integer that contains a codec
 *              specific parameter if needed. Set to 0 if not used.
 * @return
 */
swif_status_t   swif_encoder_generate_coding_coefs (
                                swif_encoder_t* enc,
                                uint32_t        key,
                                uint32_t        add_param);

swif_status_t   swif_decoder_generate_coding_coefs (
                                swif_decoder_t* dec,
                                uint32_t        key,
                                uint32_t        add_param);


/**
 * This function enables the application to retrieve the set of coding
 * coefficients generated and used by build_repair_symbol(). This is
 * useful when the choice of coefficients is performed by the codec in
 * an autonomous manner but needs to be sent in the repair packet header.
 * This function is only used by an encoder.
 *
 * @param coding_coefs_tab
 *              (OUT) pointer to a table of coding coefficients.
 *              The size (number of bits) of each coefficient depends on
 *              the FEC scheme. Upon return of this function, this table
 *              is allocated and filled with coefficient values. The
 *              release of this table is under the responsibility of the
 *              application.
 * @param nb_coefs_in_tab      
 *              (IN/OUT) pointer to the number of entries (i.e.,
 *              coefficients) in the table.
 *              Upon calling this function, this number must be zero.
 *              Upon return of this function this variable is initialized
 *              with the actual number of entries in the coeffs_tab[].
 * @return 
 */
swif_status_t   swif_encoder_get_coding_coefs_tab (
                                swif_encoder_t* enc,
                                void**          coding_coefs_tab,
                                uint32_t*       nb_coefs_in_tab);
&lt;CODE ENDS&gt;
</pre>
<p class="figure">Coding Coefficients Functions at an Encoder and Decoder.</p>
<h1 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4.</a> Encoder</h1>
<pre>
&lt;CODE BEGINS&gt;
/**
 * Throughout the API, a pointer to this structure is used as an
 * identifier of the encoder instance (or "enc").
 *
 * This generic structure is meant to be extended by each codec with
 * new pieces of information that are specific to each codec.
 */
typedef struct swif_encoder {
        /* when a function returns with SWIF_STATUS_ERROR, the errno
         * variable contains a more detailed error type. This variable
         * is set by the codec and accessible to the application in
         * READ ONLY mode. Otherwise its value is undefined. */
        swif_errno_t        errno;
} swif_encoder_t;


/**
 * Create and initialize an encoder, providing only key parameters.
 *
 * @param codepoint     opaque identifier that fully identifies the FEC
 *                      code to use.
 * @param verbosity     print information on the codec processing.
 *                      0 is the minimum verbosity, the maximum verbosity
 *                      level being implementation specific.
 * @param symbol_size   source and repair symbol size in bytes. Cannot
 *                      change during the codec instance lifetime.
 * @param max_encoding_window_size
 * @return              pointer to a swif_encoder_t structure if okay, or
 *                      NULL in case of error.
 **/
swif_encoder_t* swif_encoder_create (
                                swif_codepoint_t codepoint,
                                uint32_t        verbosity,
                                uint32_t        symbol_size,
                                uint32_t        max_coding_window_size);


/**
 * Release an encoder and its associated ressources.
 **/
swif_status_t   swif_encoder_release (swif_encoder_t*        enc);


/**
 * Set the various callback functions for this encoder.
 * All the callback functions require an opaque context parameter, that must be
 * initialized accordingly by the application, since it is application specific.
 *
 * @param enc
 * @param source_symbol_removed_from_coding_window_callback
 *              (IN) Pointer to the function, within the application, that
 *              needs to be called each time a source symbol is removed from
 *              the left side of the coding window.
 *              This callback is called each time the encoding window slides
 *              to the right and an old source symbol needs to be removed on
 *              the left. The application therefore knows this source symbol
 *              will no longer be used by the codec and can free the
 *              associated buffer if need be. This function does not return
 *              anything.
 * @param context_4_callback
 *              (IN) Pointer to the application-specific context that will be
 *              passed to the callback function (if any). This context is not
 *              interpreted by this function.
 * @return
 */
swif_status_t   swif_encoder_set_callback_functions (
                swif_encoder_t*        enc,
                void (*source_symbol_removed_from_coding_window_callback) (
                                        void*   context,
                                        esi_t   old_symbol_esi),
                void* context_4_callback);

/**
 * This function sets one or more FEC codec specific parameters,
 * using a type/length/value approach for maximum flexibility.
 *
 * @param enc
 * @param type          (IN) Type of parameter.
 * @param length        (IN) length of the pointed value.
 * @param value         (IN) Pointer to the value. The exact type of
 *                      the object pointed is FEC codec specific.
 * @return
 */
swif_status_t   swif_encoder_set_parameters  (
                                swif_encoder_t* enc,
                                uint32_t        type,
                                uint32_t        length,
                                void*           value);

/**
 * This function gets one or more FEC codec specific parameters,
 * using a type/length/value approach for maximum flexibility.
 *
 * @param enc
 * @param type          (IN) Type of parameter.
 * @param length        (IN) length of the pointed value.
 * @param value         (IN/OUT) Pointer to the value. The exact type of
 *                      the object pointed is FEC codec specific.
 *                      This function updates the value object
 *                      accordingly. The caller, who knows the FEC codec,
 *                      is responsible to allocate the appropriate
 *                      object buffer.
 * @return
 */
swif_status_t   swif_encoder_get_parameters  (
                                swif_encoder_t* enc,
                                uint32_t        type,
                                uint32_t        length,
                                void*           value);

/**
 * List here the FEC codec specific control parameters.
 */
enum {
        swif_ENCODER_GET_PARAM_ENCODER_STATISTICS = 1,
        swif_ENCODER_SET_PARAM_RLC_DENSITY_THRESHOLD
};


/**
 * Create a single repair symbol (i.e. perform an encoding).
 *
 * @param new_buf       (IN) The pointer to the buffer for the repair
 *                      symbol to build can either point to a buffer
 *                      allocated by the application, or let to NULL
 *                      meaning that this function will allocate memory.
 * @return
 */
swif_status_t   swif_build_repair_symbol (
                                swif_encoder_t* enc,
                                void*           new_buf);
&lt;CODE ENDS&gt;
</pre>
<p class="figure">Encoder API proposal</p>
<pre>
&lt;CODE BEGINS&gt;
/**
 * Encoder structure that contains whatever is needed for encoding.
 * The exact content of this structure is FEC code dependent, the
 * structure below being a non normative example.
 * However it MUST be aligned with swif_encoder_t (same first items) in
 * order to be able to cast a pointer to one of the two structures,
 * depending on the context.
 */
typedef struct swif_encoder_internal {
        /* when a function returns with SWIF_STATUS_ERROR, the errno
         * variable contains a more detailed error type. */
        swif_errno_t    errno;

        /* desired verbosity: 0 is the minimum verbosity, the maximum
         * level being implementation specific. */
        uint32_t        verbosity;

        /* maximum number of source symbols used for any repair symbol */
        uint32_t        max_coding_window_size;

        /* exact size (in bytes) of any source or repair symbol */
        uint32_t        symbol_size;

        /* add whatever may be needed hereafter... */
} swif_encoder_internal_t;
</pre>
<p class="figure">Non normative example of internal structure used by an encoder.</p>
<h1 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5.</a> Decoder</h1>
<pre>
&lt;CODE BEGINS&gt;
/**
 * Decoder structure that contains whatever is needed for decoding.
 * The exact content of this structure is FEC code dependent, the
 * structure below being a non normative example.
 */
typedef struct swif_decoder {
        /* when a function returns with SWIF_STATUS_ERROR, the errno
         * variable contains a more detailed error type. This variable
         * is set by the codec and accessible to the application in
         * READ ONLY mode. Otherwise its value is undefined. */
        swif_errno_t    errno;
} swif_decoder_t;


/**
 * Create and initialize a decoder, providing only key parameters.
 *
 * @param codepoint     opaque identifier that fully identifies the FEC
 *                      code to use.
 * @param verbosity     print information on the codec processing.
 *                      0 is the minimum verbosity, the maximum verbosity
 *                      level being implementation specific.
 * @param symbol_size   source and repair symbol size in bytes. Cannot
 *                      change during the codec instance lifetime.
 * @param max_coding_window_size
 * @param max_linear_system_size
 * @return              pointer to a swif_decoder_t structure if okay, or
 *                      NULL in case of error.
 **/
swif_decoder_t* swif_decoder_create (
                                swif_codepoint_t codepoint,
                                uint32_t        verbosity,
                                uint32_t        symbol_size,
                                uint32_t        max_coding_window_size,
                                uint32_t        max_linear_system_size);


/**
 * Release a decoder and its associated ressources.
 *
 * @param dec        context (i.e., pointer to decoder structure).
 **/
swif_status_t   swif_decoder_release (swif_decoder_t*        dec);


/**
 * Set the various callback functions for this decoder.
 * All the callback functions require an opaque context parameter, that
 * must be initialized accordingly by the application, since it is
 * application specific.
 *
 * @param dec   context (i.e., pointer to decoder structure).
 * @param source_symbol_removed_from_linear_system_callback
 *              (IN) Pointer to the function, within the application, that
 *              needs to be called each time a source symbol is removed from
 *              the left side of the linear system.
 *              This callback is called each time the linear system slides
 *              to the right and an old source symbol needs to be removed
 *              on the left. This function does not return anything.
 * @param decodable_source_symbol_callback
 *              (IN) Pointer to the function, within the application, that
 *              needs to be called each time a source symbol is decodable.
 *              What it does is application-dependent, but it MUST return
 *              either a pointer to a data buffer, left uninitialized, of
 *              the appropriate size, or NULL if the application prefers to
 *              let the codec allocate the buffer.
 *              In any case the codec is responsible for storing the actual
 *              symbol value within the data buffer. Also, no matter
 *              whether the data buffer is allocated by the application or
 *              the codec, it is the responsibility of the application to
 *              free this buffer when needed, once decoding is over (but
 *              not before since the codec does not keep any internal copy).
 * @param decoded_source_symbol_callback
 *              (IN) Pointer to the function, within the application, that
 *              needs to be called each time a source symbol is decodable and
 *              all computations performed (i.e., the buffer does contain the
 *              symbol value).
 *              This callback is called in a second time, when the newly
 *              decodable source symbol is actually decoded and ready,
 *              i.e., when all the computations (like XOR and GF(2**8)
 *              operations) have been performed. In any case, it is the
 *              responsibility of the application to free this buffer when
 *              needed, once decoding is over (but not before since the
 *              codec does not keep any internal copy). This function does
 *              not return anything.
 * @param context_4_callback
 *              (IN) Pointer to the application-specific context that will be
 *              passed to the callback function (if any). This context is not
 *              interpreted by this function.
 * @return
 */
swif_status_t   swif_decoder_set_callback_functions (
                swif_decoder_t*  dec,
                void (*source_symbol_removed_from_linear_system_callback) (
                                        void*   context,
                                        esi_t   old_symbol_esi),
                void* (*decodable_source_symbol_callback) (
                                        void    *context,
                                        esi_t   esi),
                void* (*decoded_source_symbol_callback) (
                                        void    *context,
                                        void    *new_symbol_buf,
                                        esi_t   esi),
                void*        context_4_callback);


/**
 * This function sets one or more FEC codec specific parameters,
 *        using a type/length/value approach for maximum flexibility.
 *
 * @param dec           context (i.e., pointer to decoder structure).
 * @param type          (IN) Type of parameter.
 * @param length        (IN) length of the pointed value.
 * @param value         (IN) Pointer to the value. The exact type of
 *                      the object pointed is FEC codec specific.
 * @return
 */
swif_status_t   swif_decoder_set_parameters  (
                                swif_decoder_t* dec,
                                uint32_t        type,
                                uint32_t        length,
                                void*           value);

/**
 * This function gets one or more FEC codec specific parameters,
 *        using a type/length/value approach for maximum flexibility.
 *
 * @param dec           context (i.e., pointer to decoder structure).
 * @param type          (IN) Type of parameter.
 * @param length        (IN) length of the pointed value.
 * @param value         (IN/OUT) Pointer to the value. The exact type of
 *                      the object pointed is FEC codec specific.
 *                      This function updates the value object
 *                      accordingly. The caller, who knows the FEC codec,
 *                      is responsible to allocate the appropriate
 *                      object buffer.
 * @return
 */
swif_status_t   swif_decoder_get_parameters  (
                                swif_decoder_t* dec,
                                uint32_t        type,
                                uint32_t        length,
                                void*           value);

/**
 * List here the FEC codec specific control parameters.
 */
enum {
        swif_DECODER_GET_PARAM_DECODER_STATISTICS = 1,
        swif_DECODER_SET_PARAM_RLC_DENSITY_THRESHOLD
};


/**
 * Submit a received source symbol and try to progress in the decoding.
 * For each decoded source symbol (if any), the application is informed
 * through the dedicated callback functions.
 * 
 * This function usually returns SWIF_STATUS_OK, regardless of whether
 * this new symbol enabled the decoding of one or several source symbols,
 * or SWIF_STATUS_ERROR. It cannot return SWIF_STATUS_FAILURE.
 *
 * @param dec   context (i.e., pointer to decoder structure).
 * @param new_symbol_buf
 *              (IN) Pointer to the new source symbol now available (i.e.
 *              a new symbol received by the application, or a decoded
 *              symbol in case of a recursive call if it makes sense). 
 * @param new_symbol_esi 
 *              (IN) encoding symbol ID of the new source symbol.
 * @return        
 */
swif_status_t   swif_decoder_decode_with_new_source_symbol (
                                swif_decoder_t* dec,
                                void* const     new_symbol_buf,
                                esi_t           new_symbol_esi);


/**
 * Submit a received repair symbol and try to progress in the decoding.
 * For each decoded source symbol (if any), the application is informed
 * through the dedicated callback functions.
 *
 * This function requires that the application has previously initialized
 * the coding window and coding coefficients appropriately. The application
 * keeps a full control of the repair symbol buffer, i.e., the application
 * is in charge of freeing this buffer as soon as it believes appropriate
 * (a copy is kept by the codec). This is motivated by the fact that a
 * repair symbol may be part of a larger buffer (e.g., if there are
 * several repair symbols per packet, or because of a packet header): only
 * the application knows when the buffer can be safely freed.
 *
 * This function usually returns SWIF_STATUS_OK, regardless of whether
 * this new symbol enabled the decoding of one or several source symbols,
 * or SWIF_STATUS_ERROR. It cannot return SWIF_STATUS_FAILURE.
 * 
 * @param dec   context (i.e., pointer to decoder structure).
 * @param new_symbol_buf
 *              (IN) Pointer to the new repair symbol now available (i.e.
 *              a new symbol received by the application or a decoded
 *              symbol in case of a recursive call if it makes sense).
 * @return        
 */
swif_status_t   swif_decoder_decode_with_new_repair_symbol (
                                swif_decoder_t* dec,
                                void* const     new_symbol_buf);
&lt;CODE ENDS&gt;
</pre>
<p class="figure">Decoder API proposal</p>
<pre>
&lt;CODE BEGINS&gt;
/**
 * Decoder structure that contains whatever is needed for decoding.
 * The exact content of this structure is FEC code dependent, the
 * structure below being a non normative example.
 * However it MUST be aligned with swif_decoder_t (same first items) in
 * order to be able to cast a pointer to one of the two structures,
 * depending on the context.
 */
typedef struct swif_decoder_internal {
        /* when a function returns with SWIF_STATUS_ERROR, the errno
         * variable contains a more detailed error type. */
        swif_errno_t    errno;

        /* desired verbosity: 0 is the minimum verbosity, the maximum
         * level being implementation specific. */
        uint32_t        verbosity;

        /* maximum number of source symbols used for any repair symbol */
        uint32_t        max_coding_window_size;

        /* max. number of source symbols kepts in current linear system.
         * If the linear system grows above this limit, old source
         * symbols in excess are removed and the application callback
         * called. This value should be larger than the
         * max_coding_window_size. */
        uint32_t        max_linear_system_size;

        /* exact size (in bytes) of any source or repair symbol */
        uint32_t        symbol_size;

        /* add whatever may be needed hereafter... */
} swif_decoder_internal_t;
</pre>
<p class="figure">Non normative example (RLC) of internal structure used by a decoder.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security" id="security">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">TBD </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#iana" id="iana">IANA Considerations</a></h1>
<p id="rfc.section.6.p.1">This document has no IANA requirement.  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> Acknowledgments</h1>
<p id="rfc.section.7.p.1">The authors would like to thank TBD.  </p>
<h1 id="rfc.references"><a href="#rfc.references">8.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">8.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">8.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RLC">[RLC]</b>
      </td>
      <td class="top"><a>Roca, V.</a> and <a>B. Teibi</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-rlc-fec-scheme">Sliding Window Random Linear Code (RLC) Forward Erasure Correction (FEC) Scheme for FECFRAME</a>", Transport Area Working Group (TSVWG) draft-ietf-tsvwg-rlc-fec-scheme (Work in Progress), June 2018.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="fecframe-ext">[fecframe-ext]</b>
      </td>
      <td class="top"><a>Roca, V.</a> and <a>A. Begen</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tsvwg-fecframe-ext">Forward Error Correction (FEC) Framework Extension to Sliding Window Codes</a>", Transport Area Working Group (TSVWG) draft-ietf-tsvwg-fecframe-ext (Work in Progress), June 2018.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Vincent Roca</span> 
	  <span class="n hidden">
		<span class="family-name">Roca (Ed.)</span>
	  </span>
	</span>
	<span class="org vcardline">INRIA</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Univ. Grenoble Alpes</span>,  
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:vincent.roca@inria.fr">vincent.roca@inria.fr</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Jonathan Detchart</span> 
	  <span class="n hidden">
		<span class="family-name">Detchart</span>
	  </span>
	</span>
	<span class="org vcardline">ISAE - Supaero</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:jonathan.detchart@isae-supaero.fr">jonathan.detchart@isae-supaero.fr</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Cedric Adjih</span> 
	  <span class="n hidden">
		<span class="family-name">Adjih</span>
	  </span>
	</span>
	<span class="org vcardline">INRIA</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cedric.adjih@inria.fr">cedric.adjih@inria.fr</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Morten V. Pedersen</span> 
	  <span class="n hidden">
		<span class="family-name">Pedersen</span>
	  </span>
	</span>
	<span class="org vcardline">Steinwurf ApS</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Denmark</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:morten@steinwurf.com">morten@steinwurf.com</a></span>

  </address>
</div>

</body>
</html>
